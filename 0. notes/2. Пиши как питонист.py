'''
1. Стиль написания кода:

def make_squares(key, value=0):
    """Return a dictionary and a list..."""
    d = {key: value}
    l = [key, value]
    return d, l


2. Именование
* joined_lower для функций, методов, атрибутов
* joined_lower или ALL_CAPS для констант
* StudlyCaps для классов
* camelCase только для соответствия уже существующим соглашениям
* Атрибуты: интерфейс, _internal, __private
Но старайтесь избегать формы __private. Я никогда не использую ее. Поверьте мне. Если вы ее используете, то потом будете жалеть об этом.


3. Длинные строки и продолжения
Длина строк не должна превышать 80 символов.
Используйте подразумеваемое продолжение строки в круглых скобках, скобках/браслетах:

def __init__(self, first, second, third,
             четвертый, пятый, шестой):
    output = (first + second + third
              + четвертый + пятый + шестой)
Используйте обратные косые черты в крайнем случае:

VeryLong.left_hand_side \
    = even_longer.right_hand_side()
Обратные косые черты хрупки; они должны заканчивать строку, на которой находятся.
Если вы добавите пробел после обратной косой черты, она больше не будет работать. Кроме того, они некрасивы.


4. Смежные литеральные строки конкатенируются синтаксическим анализатором:
>>> print 'o' 'n' 'e'
один
Пробелы между литералами не обязательны, но помогают читабельности. Можно использовать любой тип цитирования:

>>> print 't' r'\/\/' """o"""
t\/\/o
Строка с префиксом "r" является "сырой" строкой. Обратные косые черты не оцениваются как экранирование в необработанных строках. Они полезны для регулярных выражений и путей файловой системы Windows.

Обратите внимание, что именованные строковые объекты не конкатенируются:

>>> a = 'три'
>>> b = 'четыре'
>>> a b
  Файл "<stdin>", строка 1
    a b
      ^
SyntaxError: invalid syntax
Это потому, что автоматическая конкатенация является функцией парсера/компилятора Python, а не интерпретатора.
Вы должны использовать оператор "+" для объединения строк во время выполнения программы.

text = ('Длинные строки могут быть составлены '
        'из нескольких более коротких строк').
Круглые скобки позволяют неявно продолжить строку.

В многострочных строках используются тройные кавычки:

"""Тройные
двойные
кавычки""""

В последнем примере (тройные одинарные кавычки) обратите внимание, как обратные слеши используются для экранирования новых строк.
Это устраняет лишние новые строки, сохраняя текст и кавычки выровненными по левому краю. Обратные слэши должны находиться в конце своих строк.


5. Докстринги и комментарии
Докстринги = Как использовать код
Комментарии = Зачем (обоснование) и как работает код

Докстринги объясняют, как использовать код, и предназначены для пользователей вашего кода. Использование докстрингов:

Объясните цель функции, даже если она кажется вам очевидной, потому что она может оказаться неочевидной для кого-то другого.
Опишите ожидаемые параметры, возвращаемые значения и любые возникающие исключения.
Если метод тесно связан с единственным вызывающим лицом, упомяните о нем (хотя будьте осторожны, поскольку впоследствии вызывающее лицо может измениться).
Комментарии объясняют, почему, и предназначены для сопровождающих вашего кода. В качестве примера можно привести заметки для себя, например:

# !!! BUG: ...

# !!! FIX: Это взлом

# ??? Почему это здесь?
Обе эти группы включают и вас, так что пишите хорошие докстринги и комментарии!
Докстринги полезны при интерактивном использовании (help()) и для систем автодокументирования.
Ложные комментарии и докстринги хуже, чем полное их отсутствие.
Поэтому поддерживайте их в актуальном состоянии! Когда вы вносите изменения, убедитесь, что комментарии и докстринги соответствуют коду и не противоречат ему.
Существует целый PEP, посвященный подстрокам, PEP 257, "Docstring Conventions":

http://www.python.org/dev/peps/pep-0257/


6. Практичность побеждает чистоту
Глупое постоянство - хобгоблин маленьких умов.

-Ральф Уолдо Эмерсон

(Хобгоблин: нечто, вызывающее суеверный страх; богиня).

Всегда есть исключения. Из ПЭП 8:

Но самое главное: знайте, когда нужно быть непоследовательным - иногда руководство по стилю просто не применимо.
Если вы сомневаетесь, используйте свое лучшее суждение. Посмотрите на другие примеры и решите, что выглядит лучше. И не стесняйтесь спрашивать!

Две веские причины нарушить то или иное правило:

Когда применение правила сделает код менее читабельным, даже для того, кто привык читать код, который следует правилам.
Чтобы быть последовательным с окружающим кодом, который также нарушает это правило (возможно, по историческим причинам) - хотя это также возможность убрать чужой беспорядок (в истинном стиле XP).
... но практичность не должна побеждать чистоту!


7. Поменять значения местами
На других языках:

temp = a
a = b
b = temp
В Python:

b, a = a, b
Возможно, вы видели это раньше. Но знаете ли вы, как это работает?
Запятая - это синтаксис конструктора кортежей.
Кортеж создается справа (упаковка кортежа).
Кортеж является целью слева (распаковка кортежа).
Правая часть распаковывается в имена в кортеже с левой стороны.

Другие примеры распаковки:

>>> l =['David', 'Pythonista', '+1-514-555-1234'].
>>> имя, должность, телефон = l
>>> имя
'David'
>>> title
'Pythonista'
>>> телефон
'+1-514-555-1234'
Полезен в циклах по структурированным данным:

l (L) выше - это список, который мы только что составили (информация Дэвида).
Итак, people - это список, содержащий два элемента, каждый из которых состоит из 3 элементов.

>>> people = [l, ['Guido', 'BDFL', 'unlisted']].
>>> for (name, title, phone) in people:
... print name, phone
...
Дэвид +1-514-555-1234
Гвидо не занесен в список
Каждый элемент в people распаковывается в кортеж (имя, должность, телефон).

Возможность произвольного вложения (только убедитесь, что структура слева и справа совпадает!):

>>> david, (gname, gtitle, gphone) = people
>>> gname
'Guido'
>>> gtitle
'BDFL'
>>> gphone
'unlisted'
>>> david
['David', 'Pythonista', '+1-514-555-1234'].


8. Интерактивный "_"
Это действительно полезная функция, о которой на удивление мало кто знает.

В интерактивном интерпретаторе каждый раз, когда вы оцениваете выражение или вызываете функцию, результат привязывается к временному имени _ (знак подчеркивания):

>>> 1 + 1
2
>>> _
2
_ сохраняет последнее напечатанное выражение.

Когда результат равен None, ничего не печатается, поэтому _ не изменяется. Это удобно!

Это работает только в интерактивном интерпретаторе, а не внутри модуля.

Это особенно полезно, когда вы решаете задачу в интерактивном режиме и хотите сохранить результат для последующих действий:

>>> import math
>>> math.pi / 3
1.0471975511965976
>>> угол = _
>>> math.cos(angle)
0.50000000000000011
>>> _
0.50000000000000011


9. Building Strings, Variations 1
Here are some techniques to use the join() string method.
If you want spaces between your substrings:

result = ' '.join(colors)
Or commas and spaces:

result = ', '.join(colors)
Here's a common case:

colors = ['red', 'blue', 'green', 'yellow']
print 'Choose', ', '.join(colors[:-1]), \
      'or', colors[-1]
To make a nicely grammatical sentence, we want commas between all but the last pair of values, where we want the word "or".
The slice syntax does the job. The "slice until -1" ([:-1]) gives all but the last value, which we join with comma-space.

Of course, this code wouldn't work with corner cases, lists of length 0 or 1.

Output:
Choose red, blue, green or yellow


10. Building Strings, Variations 2
If you need to apply a function to generate the substrings:

result = ''.join(fn(i) for i in items)
This involves a generator expression, which we'll cover later.
If you need to compute the substrings incrementally, accumulate them in a list first:

items = []
...
items.append(item)  # many times
...
# items is now complete
result = ''.join(fn(i) for i in items)
We accumulate the parts in a list so that we can apply the join string method, for efficiency.


11. Используйте in там, где это возможно (1)

Хорошо:
for key in d:
    вывести ключ
in обычно быстрее.
Эта схема также работает для элементов в произвольных контейнерах (таких как списки, кортежи и множества).
in также является оператором (как мы увидим).

Плохо:
for key in d.keys():
    print key
Это ограничено объектами с методом keys().


12. Используйте in там, где это возможно (2)
Но .keys() необходим при мутации словаря:

for key in d.keys():
    d[str(key)] = d[key].
d.keys() создает статический список ключей словаря. В противном случае вы получите исключение "RuntimeError: словарь изменил размер во время итерации".
Для согласованности используйте key в dict, а не dict.has_key():

# сделайте это:
if key in d:
    ... сделайте что-нибудь с d[key].

# не это:
if d.has_key(key):
    ...сделать что-то с d[key].
В данном случае in используется как оператор.


13. Метод словаря setdefault (1)
Здесь мы должны инициализировать изменяемые значения словаря. Каждое значение словаря будет представлять собой список. Это наивный способ:
Инициализация изменяемых значений словаря:

equities = {}
for (portfolio, equity) in data:
    if portfolio in equities:
        equities[portfolio].append(equity)
    else:
        equities[portfolio] = [equity]
dict.setdefault(key, default) выполняет эту работу гораздо эффективнее:

equities = {}
for (portfolio, equity) in data:
    equities.setdefault(portfolio, []).append(
                                         equity)
dict.setdefault() эквивалентен "get, or set & get". Или "установить при необходимости, затем получить". Это особенно эффективно, если ключ вашего словаря дорого вычислять или долго набирать.

Единственная проблема с dict.setdefault() заключается в том, что значение по умолчанию всегда оценивается, независимо от того, нужно оно или нет. Это имеет значение, только если значение по умолчанию дорого вычислять.

Если вычисление значения по умолчанию требует больших затрат, то лучше использовать класс defaultdict, который мы рассмотрим в ближайшее время.


14. Метод setdefault словаря (2)
Здесь мы видим, что метод словаря setdefault также может быть использован как отдельный оператор:
setdefault также может быть использован как отдельный оператор:

navs = {}
for (portfolio, equity, position) in data:
    navs.setdefault(portfolio, 0)
    navs[portfolio] += position * prices[equity]
Метод словаря setdefault возвращает значение по умолчанию, но здесь мы его игнорируем. Мы воспользуемся побочным эффектом метода setdefault, который устанавливает значение словаря только в том случае, если его еще нет.
defaultdict
Новое в Python 2.5.

defaultdict - новый модуль в Python 2.5, часть модуля коллекций. defaultdict идентичен обычным словарям, за исключением двух моментов:

он принимает дополнительный первый аргумент: фабричную функцию по умолчанию; и
когда ключ словаря встречается впервые, вызывается фабричная функция по умолчанию, а результат используется для инициализации значения словаря.
Есть два способа получить defaultdict:

импортировать модуль collections и сослаться на него через модуль,

➔

или импортируйте имя defaultdict напрямую:

➔

импортировать коллекции
d = collections.defaultdict(...)
из collections import defaultdict
d = defaultdict(...)
Вот пример из предыдущего раздела, где каждое значение словаря должно быть инициализировано пустым списком, переписанный как с помощью defaultdict:
from collections import defaultdict

акции = defaultdict(list)
for (portfolio, equity) in data:
    equities[portfolio].append(equity)
Теперь не нужно возиться. В данном случае фабричной функцией по умолчанию является list, которая возвращает пустой список.

Вот как получить словарь со значениями по умолчанию, равными 0: используйте int в качестве заводской функции по умолчанию:

navs = defaultdict(int)
for (portfolio, equity, position) in data:
    navs[portfolio] += position * prices[equity]
Однако с defaultdict следует быть осторожным. Вы не можете получить исключения KeyError из правильно инициализированных экземпляров defaultdict.
Вы должны использовать условие "ключ в dict", если вам нужно проверить существование определенного ключа.


15.
Построение и разделение словарей
Вот полезная техника построения словаря из двух списков (или последовательностей): один список ключей, другой список значений.
given = ['John', 'Eric', 'Terry', 'Michael'].
family = ['Cleese', 'Idle', 'Gilliam', 'Palin'].
pythons = dict(zip(given, family))
>>> pprint.pprint(pythons)
{'Джон': 'Клиз',
'Майкл': 'Пэлин',
'Эрик': 'Idle',
'Терри': 'Гиллиам'}
Обратное, конечно, тривиально:
>>> pythons.keys()
['John', 'Michael', 'Eric', 'Terry'].
>>> pythons.values()
['Cleese', 'Palin', 'Idle', 'Gilliam'].
Обратите внимание, что порядок результатов .keys() и .values() отличается от порядка элементов при построении словаря. Порядок входящих элементов отличается от порядка исходящих. Это происходит потому, что словарь по своей природе неупорядочен. Однако порядок гарантированно будет последовательным (другими словами, порядок ключей будет соответствовать порядку значений), если словарь не изменяется между вызовами.


16. Проверка на истинность значений
# do this:        # not this:
if x:             if x == True:
    pass              pass
Элегантно и эффективно использовать присущие объектам Python значения истинности (или булевы значения).
Проверка списка:

# do this:        # not this:
if items:         if len(items) != 0:
    pass              pass

                  # and definitely not this:
                  if items != []:
                      pass


17. Index & Item (1)
Here's a cute way to save some typing if you need a list of words:
>>> items = 'zero one two three'.split()
>>> print items
['zero', 'one', 'two', 'three']
Say we want to iterate over the items, and we need both the item's index and the item itself:

                  - or -
i = 0
for item in items:      for i in range(len(items)):
    print i, item               print i, items[i]
    i += 1


18. Index & Item (2): enumerate
The enumerate function takes a list and returns (index, item) pairs:

>>> print list(enumerate(items))
[(0, 'zero'), (1, 'one'), (2, 'two'), (3, 'three')]
Our loop becomes much simpler:

for (index, item) in enumerate(items):
    print index, item

>>> enumerate(items)
<enumerate object at 0x011EA1C0>
>>> e = enumerate(items)
>>> e.next()
(0, 'zero')
>>> e.next()
(1, 'one')
>>> e.next()
(2, 'two')
>>> e.next()
(3, 'three')
>>> e.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
StopIteration


19. Значения параметров по умолчанию
Это распространенная ошибка, которую часто допускают новички. Даже более опытные программисты допускают эту ошибку, если не понимают имен Python.
def bad_append(new_item, a_list=[]):
    a_list.append(new_item)
    return a_list
Проблема здесь в том, что значение по умолчанию a_list, пустой список, оценивается во время определения функции.
Поэтому каждый раз, когда вы вызываете функцию, вы получаете одно и то же значение по умолчанию. Попробуйте сделать это несколько раз:
>>> print bad_append('one')
['one']
>>> print bad_append('two')
['one', 'two'].
Списки - это изменяемые объекты; вы можете изменять их содержимое. Правильный способ получить список (или словарь, или набор) по умолчанию -
создать его во время выполнения, а не внутри функции:
def good_append(new_item, a_list=None):
    if a_list is None:
        a_list = []
    a_list.append(new_item)
    return a_list


20. Форматирование строк с помощью оператора %
Оператор % в Python работает как функция sprintf в C.
Хотя, если вы не знаете C, это не очень поможет. В основном, вы предоставляете шаблон или формат и значения интерполяции.

В этом примере шаблон содержит две спецификации преобразования: "%s" означает "вставить сюда строку", а "%i" означает
"преобразовать целое число в строку и вставить сюда". "%s" особенно полезен, поскольку он использует встроенную в Python функцию str()
для преобразования любого объекта в строку.

Значения интерполяции должны соответствовать шаблону; здесь у нас два значения, кортеж.

имя = 'Дэвид'
сообщения = 3
text = ('Привет %s, у вас %i сообщений'
        % (имя, сообщения))
вывести текст
Вывод:

Здравствуйте Дэвид, у вас 3 сообщения
Подробности в справочнике по библиотеке Python, раздел 2.3.6.2, "Операции форматирования строк". Сохраните его в закладках!
Если вы еще не сделали этого, зайдите на python.org, скачайте документацию HTML (в .zip-файле или tarball) и установите
ее на свою машину. Нет ничего лучше, чем иметь под рукой исчерпывающий ресурс.


21. Расширенное % форматирование строк
Многие люди не понимают, что существуют другие, более гибкие способы форматирования строк:
По имени с помощью словаря:

values = {'name': name, 'messages': messages}
print ('Hello %(name)s, you have %(messages)i '
       'messages' % values)
Здесь мы указываем имена интерполяционных значений, которые ищутся в предоставленном словаре.

Заметили избыточность? Имена "name" и "messages" уже определены в локальном пространстве имен. Мы можем воспользоваться этим.

По имени, используя локальное пространство имен:

print ('Hello %(name)s, you have %(messages)i '
       'messages' % locals())
Функция locals() возвращает словарь всех локально доступных имен.

Это очень мощная функция. С ее помощью вы можете выполнять любое форматирование строк, не заботясь о соответствии значений интерполяции шаблону.

Но сила может быть опасной. ("С большой властью приходит большая ответственность"). Если вы используете форму locals() со строкой шаблона, предоставленной извне, вы открываете все свое локальное пространство имен вызывающей стороне. Это просто нужно иметь в виду.

Чтобы исследовать ваше локальное пространство имен:

>>> from pprint import pprint
>>> pprint(locals())
pprint - очень полезный модуль. Если вы еще не знакомы с ним, попробуйте поиграть с ним. Он значительно облегчает отладку структур данных!


22. Понимание списков
Понимание списков ("listcomps" для краткости) - это синтаксические сокращения для этого общего шаблона:
Традиционный способ, с использованием операторов for и if:

new_list = []
for item in a_list:
    if condition(item):
        new_list.append(fn(item)).
В качестве понимания списка:

new_list = [fn(item) for item in a_list
            if condition(item)]
Списочные композиции ясны и лаконичны, до определенного момента. Вы можете использовать несколько циклов for и if-условий в списке, но после двух или трех циклов, или если условия сложные, я рекомендую использовать обычные циклы for. Применяя дзен Python, выбирайте более читабельный способ.
Например, список квадратов 0-9:

>>> [n ** 2 for n in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Список квадратов нечетных 0-9:

>>> [n ** 2 for n in range(10) if n % 2]
[1, 9, 25, 49, 81]


23. Generator Expressions (1)
Let's sum the squares of the numbers up to 100:
As a loop:

total = 0
for num in range(1, 101):
    total += num * num
We can use the sum function to quickly do the work for us, by building the appropriate sequence.
As a list comprehension:

total = sum([num * num for num in range(1, 101)])
As a generator expression:

total = sum(num * num for num in xrange(1, 101))
Generator expressions ("genexps") are just like list comprehensions, except that where listcomps are greedy, generator expressions are lazy.
Listcomps compute the entire result list all at once, as a list. Generator expressions compute one value at a time, when needed, as individual values.
This is especially useful for long sequences where the computed list is just an intermediate step and not the final result.

In this case, we're only interested in the sum; we don't need the intermediate list of squares. We use xrange for the same reason: it lazily produces values, one at a time.


24. Генераторные выражения (2)
Например, если бы мы суммировали квадраты нескольких миллиардов целых чисел, мы бы исчерпали память при использовании списков, но генераторные выражения не имеют проблем. Однако это занимает время!
total = sum(num * num
            for num in xrange(1, 1000000000))
Разница в синтаксисе заключается в том, что у списковых выражений есть квадратные скобки, а у генераторных - нет. Однако выражения-генераторы иногда требуют заключающих круглых скобок, поэтому их всегда следует использовать.
Эмпирическое правило:

Используйте вычисление списка, когда вычисляемый список является желаемым конечным результатом.
Используйте выражение-генератор, если вычисляемый список является лишь промежуточным шагом.
Вот недавний пример, который я видел на работе.

➔
Нам понадобился словарь, отображающий номера месяцев (как в виде строки, так и в виде целых чисел) на коды месяцев для фьючерсных контрактов. Это можно сделать в одной логической строке кода.

➔
Это работает следующим образом:

Встроенная функция dict() принимает список пар ключ/значение (2-кортежи).
У нас есть список кодов месяцев (каждый код месяца - это одна буква, а строка - это тоже просто список букв). Мы перечисляем этот список, чтобы получить код месяца и индекс.
Номера месяцев начинаются с 1, но Python начинает индексировать с 0, поэтому номер месяца на один больше, чем индекс.
Мы хотим найти месяцы как в виде строк, так и в виде целых чисел. Мы можем использовать функции int() и str(), чтобы сделать это за нас, и перебирать их в цикле.
Недавний пример:

month_codes = dict((fn(i+1), code)
    for i, code in enumerate('FGHJKMNQUVXZ')
    for fn in (int, str))
month_codes result:

{ 1: 'F', 2: 'G', 3: 'H', 4: 'J', ...
 '1': 'F', '2': 'G', '3': 'H', '4': 'J', ...}


 25. Правило большого пальца:

1. Используйте list comprehension, когда вычисляемый список является желаемым конечным результатом.
2. Используйте generator expression, если вычисляемый список является лишь промежуточным шагом.


26. Импорт библиотек

Never!
The from module import *

Instead:
Reference names through their module (fully qualified identifiers):
    import module
    module.name
Or import a long module using a shorter name (alias):
    import long_module_name as mod
    mod.name
Or explicitly import just the names you need:
    from module import name
    name


27. Module Structure
"""module docstring"""

# imports
# constants
# exception classes
# interface functions
# classes
# internal functions & classes

def main(...):
    ...

if __name__ == '__main__':
    status = main()
    sys.exit(status)
This is how a module should be structured.


28. Модули и скрипты
Для создания одновременно импортируемого модуля и исполняемого скрипта:

if __name__ == '__main__':
    # код скрипта здесь
При импорте атрибут __name__ модуля устанавливается в имя файла модуля, без ".py".
Поэтому код, охраняемый приведенным выше оператором if, не будет выполняться при импорте. Однако при выполнении в качестве сценария атрибут __name__ устанавливается в значение "__main__", и код сценария будет запущен.

За исключением особых случаев, не следует размещать основной исполняемый код на верхнем уровне. П
омещайте код в функции, классы, методы и защищайте его с помощью if __name__ == '__main__'.


'''